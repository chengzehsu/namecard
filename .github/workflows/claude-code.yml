name: Claude Code AI è‡ªå‹•åŒ–

# ç•¶ Issue è¢«æ¨™è¨˜æˆ–è©•è«–æ™‚è§¸ç™¼
on:
  issues:
    types: [opened, labeled, edited]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      feature_description:
        description: 'è¦å¯¦ç¾çš„åŠŸèƒ½æè¿°'
        required: true
        type: string
      issue_number:
        description: 'ç›¸é—œçš„ Issue ç·¨è™Ÿ (å¯é¸)'
        required: false
        type: string

env:
  PYTHON_VERSION: '3.9'

jobs:
  # è‡ªå‹• PR å‰µå»ºå·¥ä½œæµç¨‹
  auto-pr-creation:
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'claude-code')) ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude-code')) ||
      (github.event_name == 'workflow_dispatch')
    
    steps:
    - name: Checkout ä»£ç¢¼
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: è¨­ç½® Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: å®‰è£ä¾è³´
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: æº–å‚™ Claude Code ç’°å¢ƒ
      env:
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      run: |
        echo "ğŸ¤– æº–å‚™ Claude Code AI ç’°å¢ƒ"
        
        # æª¢æŸ¥ API Keys
        if [ -z "$ANTHROPIC_API_KEY" ] && [ -z "$OPENAI_API_KEY" ]; then
          echo "âš ï¸ è­¦å‘Š: æ²’æœ‰æ‰¾åˆ° ANTHROPIC_API_KEY æˆ– OPENAI_API_KEY"
          echo "è«‹åœ¨ GitHub Secrets ä¸­è¨­ç½® AI API key"
        fi
        
        # å®‰è£ Claude Code (å¦‚æœå¯ç”¨)
        # npm install -g @anthropic-ai/claude-code || echo "Claude Code CLI æš«æ™‚ä¸å¯ç”¨ï¼Œä½¿ç”¨å…§å»ºé‚è¼¯"
        
    - name: è§£æéœ€æ±‚
      id: parse_request
      run: |
        echo "ğŸ” è§£æåŠŸèƒ½éœ€æ±‚..."
        
        # å¾ä¸åŒä¾†æºæå–éœ€æ±‚æè¿°
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          DESCRIPTION="${{ github.event.inputs.feature_description }}"
          ISSUE_NUM="${{ github.event.inputs.issue_number }}"
        elif [ "${{ github.event_name }}" == "issues" ]; then
          DESCRIPTION="${{ github.event.issue.title }}: ${{ github.event.issue.body }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
        elif [ "${{ github.event_name }}" == "issue_comment" ]; then
          DESCRIPTION="${{ github.event.comment.body }}"
          ISSUE_NUM="${{ github.event.issue.number }}"
        fi
        
        echo "feature_description=${DESCRIPTION}" >> $GITHUB_OUTPUT
        echo "issue_number=${ISSUE_NUM}" >> $GITHUB_OUTPUT
        
        echo "ğŸ“ åŠŸèƒ½æè¿°: ${DESCRIPTION}"
        echo "ğŸ”— ç›¸é—œ Issue: #${ISSUE_NUM}"
        
    - name: ç”Ÿæˆåˆ†æ”¯åç¨±
      id: branch_name
      run: |
        # ç”Ÿæˆæœ‰æ„ç¾©çš„åˆ†æ”¯åç¨±
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        ISSUE_NUM="${{ steps.parse_request.outputs.issue_number }}"
        
        if [ -n "$ISSUE_NUM" ]; then
          BRANCH_NAME="feature/issue-${ISSUE_NUM}-${TIMESTAMP}"
        else
          BRANCH_NAME="feature/claude-auto-${TIMESTAMP}"
        fi
        
        echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
        echo "ğŸŒ¿ åˆ†æ”¯åç¨±: ${BRANCH_NAME}"
        
    - name: å‰µå»ºåŠŸèƒ½åˆ†æ”¯
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "Claude Code GitHub Action"
        
        BRANCH_NAME="${{ steps.branch_name.outputs.branch_name }}"
        git checkout -b ${BRANCH_NAME}
        echo "âœ… å‰µå»ºåˆ†æ”¯: ${BRANCH_NAME}"
        
    - name: åˆ†æå°ˆæ¡ˆçµæ§‹
      id: analyze_project
      run: |
        echo "ğŸ” åˆ†æå°ˆæ¡ˆçµæ§‹..."
        
        # æª¢æŸ¥ä¸»è¦æ–‡ä»¶
        echo "ğŸ“ ä¸»è¦æ–‡ä»¶:"
        ls -la *.py | head -10
        
        # åˆ†ææ¨¡çµ„çµæ§‹
        echo "ğŸ“¦ Python æ¨¡çµ„:"
        find . -name "*.py" -not -path "./.git/*" -not -path "./.venv/*" | head -20
        
        # æª¢æŸ¥é…ç½®æ–‡ä»¶
        echo "âš™ï¸ é…ç½®æ–‡ä»¶:"
        ls -la requirements*.txt CLAUDE.md config.py 2>/dev/null || echo "é…ç½®æ–‡ä»¶æª¢æŸ¥å®Œæˆ"
        
        # è®€å–å°ˆæ¡ˆæŒ‡å°åŸå‰‡
        if [ -f "CLAUDE.md" ]; then
          echo "ğŸ“‹ è®€å– CLAUDE.md æŒ‡å°åŸå‰‡..."
          head -50 CLAUDE.md
        fi
        
    - name: AI åŠŸèƒ½å¯¦ç¾ (æ¨¡æ“¬)
      id: implement_feature
      env:
        FEATURE_DESC: ${{ steps.parse_request.outputs.feature_description }}
      run: |
        echo "ğŸ¤– é–‹å§‹ AI åŠŸèƒ½å¯¦ç¾..."
        echo "ğŸ“ éœ€æ±‚: ${FEATURE_DESC}"
        
        # æ¨¡æ“¬ Claude Code çš„åŠŸèƒ½å¯¦ç¾
        # åœ¨å¯¦éš›ä½¿ç”¨ä¸­ï¼Œé€™è£¡æœƒèª¿ç”¨ Claude Code API
        
        # å‰µå»ºç¤ºä¾‹æ”¹é€²ï¼ˆåŸºæ–¼å¸¸è¦‹éœ€æ±‚æ¨¡å¼ï¼‰
        if echo "${FEATURE_DESC}" | grep -i "test\|æ¸¬è©¦"; then
          echo "ğŸ§ª æª¢æ¸¬åˆ°æ¸¬è©¦ç›¸é—œéœ€æ±‚ï¼Œå‰µå»ºæ¸¬è©¦æ–‡ä»¶..."
          
          cat > test_auto_generated.py << 'EOF'
# Auto-generated test file by Claude Code
import unittest
from app import app

class TestAutoGenerated(unittest.TestCase):
    def setUp(self):
        self.app = app.test_client()
        
    def test_health_endpoint(self):
        """æ¸¬è©¦å¥åº·æª¢æŸ¥ç«¯é»"""
        response = self.app.get('/health')
        self.assertEqual(response.status_code, 200)
        
    def test_callback_endpoint_get(self):
        """æ¸¬è©¦ GET /callback ç«¯é»"""
        response = self.app.get('/callback')
        self.assertEqual(response.status_code, 200)

if __name__ == '__main__':
    unittest.main()
EOF
          
          echo "changes_made=created_test_file" >> $GITHUB_OUTPUT
          
        elif echo "${FEATURE_DESC}" | grep -i "log\|ç´€éŒ„\|è¨˜éŒ„"; then
          echo "ğŸ“ æª¢æ¸¬åˆ°æ—¥èªŒç›¸é—œéœ€æ±‚ï¼Œå„ªåŒ–æ—¥èªŒåŠŸèƒ½..."
          
          # å‰µå»ºæ—¥èªŒé…ç½®æ–‡ä»¶
          cat > logging_config.py << 'EOF'
# Auto-generated logging configuration by Claude Code
import logging
import logging.handlers
import os

def setup_logging():
    """è¨­ç½®æ‡‰ç”¨æ—¥èªŒé…ç½®"""
    # å‰µå»º logs ç›®éŒ„
    os.makedirs('logs', exist_ok=True)
    
    # é…ç½®æ—¥èªŒæ ¼å¼
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # æ–‡ä»¶è™•ç†å™¨ (æ¯æ—¥è¼ªè½‰)
    file_handler = logging.handlers.TimedRotatingFileHandler(
        'logs/app.log', when='midnight', interval=1, backupCount=7
    )
    file_handler.setFormatter(formatter)
    file_handler.setLevel(logging.INFO)
    
    # æ§åˆ¶å°è™•ç†å™¨
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    console_handler.setLevel(logging.INFO)
    
    # æ ¹æ—¥èªŒå™¨é…ç½®
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)
    
    return root_logger

# ä½¿ç”¨ç¤ºä¾‹
logger = setup_logging()
EOF
          
          echo "changes_made=created_logging_config" >> $GITHUB_OUTPUT
          
        elif echo "${FEATURE_DESC}" | grep -i "doc\|æ–‡æª”\|èªªæ˜"; then
          echo "ğŸ“š æª¢æ¸¬åˆ°æ–‡æª”ç›¸é—œéœ€æ±‚ï¼Œå‰µå»º API æ–‡æª”..."
          
          cat > API_DOCS.md << 'EOF'
# åç‰‡ç®¡ç† LINE Bot API æ–‡æª”

> ğŸ¤– Auto-generated by Claude Code

## API ç«¯é»

### 1. å¥åº·æª¢æŸ¥
- **URL**: `/health`
- **æ–¹æ³•**: GET
- **æè¿°**: æª¢æŸ¥æœå‹™ç‹€æ…‹
- **å›æ‡‰**: `{"status": "healthy", "message": "LINE Bot is running"}`

### 2. Webhook å›èª¿
- **URL**: `/callback`  
- **æ–¹æ³•**: POST
- **æè¿°**: LINE Bot webhook ç«¯é»
- **Headers**: 
  - `Content-Type: application/json`
  - `X-Line-Signature: <signature>`

### 3. æœå‹™æ¸¬è©¦
- **URL**: `/test`
- **æ–¹æ³•**: GET  
- **æè¿°**: æ¸¬è©¦å„æœå‹™é€£æ¥ç‹€æ…‹
- **å›æ‡‰**: 
  ```json
  {
    "notion": {"success": true, "message": "é€£æ¥æ­£å¸¸"},
    "gemini": {"success": true, "message": "Gemini é€£æ¥æ­£å¸¸"}
  }
  ```

## LINE Bot æŒ‡ä»¤

| æŒ‡ä»¤ | åŠŸèƒ½ | ç¯„ä¾‹å›æ‡‰ |
|------|------|----------|
| `æ‰¹æ¬¡` | å•Ÿå‹•æ‰¹æ¬¡æ¨¡å¼ | "å·²é€²å…¥æ‰¹æ¬¡æ¨¡å¼..." |
| `çµæŸæ‰¹æ¬¡` | çµæŸæ‰¹æ¬¡è™•ç† | "æ‰¹æ¬¡è™•ç†å®Œæˆçµ±è¨ˆ..." |
| `ç‹€æ…‹` | æŸ¥çœ‹æ‰¹æ¬¡ç‹€æ…‹ | "ç›®å‰è™•ç†é€²åº¦..." |
| `help` | é¡¯ç¤ºå¹«åŠ© | "ä½¿ç”¨èªªæ˜..." |

## ç’°å¢ƒè®Šæ•¸

- `LINE_CHANNEL_ACCESS_TOKEN`: LINE Bot å­˜å–æ¬Šæ–
- `LINE_CHANNEL_SECRET`: LINE Bot å¯†é‘°
- `GOOGLE_API_KEY`: Google Gemini API é‡‘é‘°
- `NOTION_API_KEY`: Notion API é‡‘é‘°  
- `NOTION_DATABASE_ID`: Notion è³‡æ–™åº« ID
EOF
          
          echo "changes_made=created_api_docs" >> $GITHUB_OUTPUT
        
        else
          echo "ğŸ”§ é€šç”¨åŠŸèƒ½å„ªåŒ–..."
          
          # å‰µå»ºé€šç”¨çš„åŠŸèƒ½æ”¹é€²
          cat > utils.py << 'EOF'
# Auto-generated utility functions by Claude Code
import time
import functools
import logging

def timing_decorator(func):
    """æ¸¬é‡å‡½æ•¸åŸ·è¡Œæ™‚é–“çš„è£é£¾å™¨"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        logging.info(f"{func.__name__} åŸ·è¡Œæ™‚é–“: {execution_time:.2f}ç§’")
        return result
    return wrapper

def retry_on_failure(max_retries=3, delay=1):
    """å¤±æ•—é‡è©¦è£é£¾å™¨"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_retries - 1:
                        raise e
                    logging.warning(f"{func.__name__} ç¬¬{attempt + 1}æ¬¡å˜—è©¦å¤±æ•—: {e}")
                    time.sleep(delay)
            return None
        return wrapper
    return decorator

def validate_environment():
    """é©—è­‰ç’°å¢ƒè®Šæ•¸"""
    import os
    required_vars = [
        'LINE_CHANNEL_ACCESS_TOKEN',
        'LINE_CHANNEL_SECRET', 
        'GOOGLE_API_KEY',
        'NOTION_API_KEY',
        'NOTION_DATABASE_ID'
    ]
    
    missing_vars = []
    for var in required_vars:
        if not os.getenv(var):
            missing_vars.append(var)
    
    if missing_vars:
        raise ValueError(f"ç¼ºå°‘å¿…è¦çš„ç’°å¢ƒè®Šæ•¸: {', '.join(missing_vars)}")
    
    return True
EOF
          
          echo "changes_made=created_utility_functions" >> $GITHUB_OUTPUT
        fi
        
    - name: é‹è¡Œæ¸¬è©¦é©—è­‰
      run: |
        echo "ğŸ§ª é‹è¡Œæ¸¬è©¦é©—è­‰æ”¹å‹•..."
        
        # æª¢æŸ¥ Python èªæ³•
        python -m py_compile *.py 2>/dev/null || echo "éƒ¨åˆ†æ–‡ä»¶éœ€è¦ä¾è³´æ‰èƒ½ç·¨è­¯"
        
        # é‹è¡ŒåŸºæœ¬å°å…¥æ¸¬è©¦
        python -c "import sys; print('âœ… Python åŸºæœ¬åŠŸèƒ½æ­£å¸¸')"
        
        echo "âœ… åŸºæœ¬é©—è­‰å®Œæˆ"
        
    - name: æäº¤è®Šæ›´
      run: |
        git add .
        
        CHANGES="${{ steps.implement_feature.outputs.changes_made }}"
        FEATURE_DESC="${{ steps.parse_request.outputs.feature_description }}"
        ISSUE_NUM="${{ steps.parse_request.outputs.issue_number }}"
        
        COMMIT_MSG="feat: Auto-implement feature by Claude Code

åŠŸèƒ½æè¿°: ${FEATURE_DESC}
å¯¦ç¾å…§å®¹: ${CHANGES}
$([ -n "$ISSUE_NUM" ] && echo "ç›¸é—œ Issue: #${ISSUE_NUM}")

ğŸ¤– Generated with Claude Code GitHub Actions

Co-Authored-By: Claude-Code-Bot <claude-code@anthropic.com>"

        git commit -m "${COMMIT_MSG}" || echo "æ²’æœ‰è®Šæ›´éœ€è¦æäº¤"
        
    - name: æ¨é€åˆ†æ”¯ä¸¦å‰µå»º PR
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        BRANCH_NAME="${{ steps.branch_name.outputs.branch_name }}"
        FEATURE_DESC="${{ steps.parse_request.outputs.feature_description }}"
        ISSUE_NUM="${{ steps.parse_request.outputs.issue_number }}"
        CHANGES="${{ steps.implement_feature.outputs.changes_made }}"
        
        # æ¨é€åˆ†æ”¯
        git push origin ${BRANCH_NAME}
        
        # å‰µå»º PR
        PR_TITLE="ğŸ¤– Auto-implementation: $(echo ${FEATURE_DESC} | cut -c1-50)..."
        
        PR_BODY="## ğŸ¤– Claude Code è‡ªå‹•å¯¦ç¾

### ğŸ“ åŠŸèƒ½æè¿°
${FEATURE_DESC}

### ğŸ”§ å¯¦ç¾å…§å®¹
- ${CHANGES}

### ğŸ§ª æ¸¬è©¦ç‹€æ…‹
- âœ… èªæ³•æª¢æŸ¥é€šé
- âœ… åŸºæœ¬åŠŸèƒ½é©—è­‰å®Œæˆ

### ğŸ“‹ æª¢æŸ¥æ¸…å–®
- [ ] ä»£ç¢¼å¯©æŸ¥
- [ ] åŠŸèƒ½æ¸¬è©¦
- [ ] æ•´åˆæ¸¬è©¦
- [ ] éƒ¨ç½²æº–å‚™

$([ -n "$ISSUE_NUM" ] && echo "### ğŸ”— ç›¸é—œ Issue
Closes #${ISSUE_NUM}")

---
ğŸ¤– Generated with [Claude Code](https://claude.ai/code) GitHub Actions"

        # ä½¿ç”¨ GitHub CLI å‰µå»º PR (å¦‚æœå¯ç”¨) æˆ–ä½¿ç”¨ API
        if command -v gh &> /dev/null; then
          gh pr create --title "${PR_TITLE}" --body "${PR_BODY}" --head ${BRANCH_NAME} --base main
        else
          echo "ğŸ“ PR ä¿¡æ¯å·²æº–å‚™ï¼Œè«‹æ‰‹å‹•å‰µå»º PR:"
          echo "æ¨™é¡Œ: ${PR_TITLE}"
          echo "åˆ†æ”¯: ${BRANCH_NAME}"
        fi
        
    - name: æ›´æ–° Issue (å¦‚æœå­˜åœ¨)
      if: steps.parse_request.outputs.issue_number != ''
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        ISSUE_NUM="${{ steps.parse_request.outputs.issue_number }}"
        BRANCH_NAME="${{ steps.branch_name.outputs.branch_name }}"
        
        # åœ¨ Issue ä¸­æ·»åŠ è©•è«–
        COMMENT="ğŸ¤– **Claude Code è‡ªå‹•è™•ç†æ›´æ–°**

âœ… å·²è‡ªå‹•å‰µå»ºå¯¦ç¾åˆ†æ”¯: \`${BRANCH_NAME}\`
ğŸ”§ åŠŸèƒ½å¯¦ç¾å·²å®Œæˆï¼Œè«‹æŸ¥çœ‹ç›¸é—œ PR é€²è¡Œä»£ç¢¼å¯©æŸ¥

---
*Powered by Claude Code GitHub Actions*"

        if command -v gh &> /dev/null; then
          echo "${COMMENT}" | gh issue comment ${ISSUE_NUM} --body-file -
        else
          echo "ğŸ’¬ Issue è©•è«–å…§å®¹å·²æº–å‚™: ${COMMENT}"
        fi

  # é€šçŸ¥å·¥ä½œæµç¨‹
  notify-completion:
    runs-on: ubuntu-latest
    needs: auto-pr-creation
    if: always()
    
    steps:
    - name: å·¥ä½œæµç¨‹å®Œæˆé€šçŸ¥
      run: |
        if [ "${{ needs.auto-pr-creation.result }}" == "success" ]; then
          echo "ğŸ‰ Claude Code è‡ªå‹•å¯¦ç¾å®Œæˆï¼"
          echo "âœ… åŠŸèƒ½å·²å¯¦ç¾ä¸¦å‰µå»º PR"
          echo "ğŸ‘€ è«‹æŸ¥çœ‹ PR é€²è¡Œä»£ç¢¼å¯©æŸ¥"
        else
          echo "âš ï¸ Claude Code è‡ªå‹•å¯¦ç¾é‡åˆ°å•é¡Œ"
          echo "ğŸ” è«‹æª¢æŸ¥å·¥ä½œæµç¨‹æ—¥èªŒ"
        fi